{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "KafkaConfig": {
    "KafkaConfigItems": [
      {
        "Name": "bootstrap.servers",
        "Value": "192.168.50.71:9092,192.168.50.124:9092,192.168.50.116:9092"
      }
    ],
    "ProducerConfigItems": [
      {
        "Name": "allow.auto.create.topics",
        "Value": 1
      },
      {
        "Name": "broker.address.ttl", // BootstrapServers parametresinde belirtilen broker adreslerinin ne süre cache'de tutulacağını belirtir.
        "Value": 3600000
      },
      {
        "Name": "dotnet.cancellation.delay.max.ms", // Bir işlem iptal edildiğinde (CancellationToken ile), Kafka arka planda hala devam etmekte olan bir çağrıyı temizlemeye çalışırken ne kadar süre bekleyeceğini belirler.
        "Value": 1000
      },
      {
        "Name": "connections.max.idle.ms",
        "Value": 0
      },
      {
        "Name": "client.id",
        "Value": "Kafka_Producer"
      },
      {
        "Name": "acks", // Üretilen mesaj tüm replikalara yazılana kadar producer thread'i block'lanır. Mesaj kaybı olmaması açısından en güvenli yöntem budur.
        "Value": -1
      },
      {
        "Name": "message.timeout.ms",
        "Value": 5000
      },
      {
        "Name": "socket.connection.setup.timeout.ms",
        "Value": 3000
      },
      {
        "Name": "compression.level", // Sıkıştırma oranı ne kadar yüksek olursa cpu kullanımı o kadar artar. Kafka performansı yükselir. 
        "Value": 5
      },
      {
        "Name": "compression.type", // Gzip
        "Value": "gzip"
      },
      {
        "Name": "enable.idempotence", // Retry edilen bir mesajın birden fazla kez kaydedilmesi engelleniyor. Aynı zamanda sırası da korunuyor.
        "Value": 1
      },
      {
        "Name": "message.send.max.retries", // Başarısız olan mesajın kaç kez retry edileceği ayarlanıyor.
        "Value": 3
      },
      {
        "Name": "retry.backoff.ms", // Başarısız bir mesaj retry edilirken, retry'lar arasında ne kadar süre bekleneceğini ayarlar.
        "Value": 5000
      },
      {
        "Name": "retry.backoff.max.ms", // Başarısız bir mesaj retry edilirken, retry'lar arasında ne kadar süre bekleneceğini ayarlar.
        "Value": 5000
      }
    ],
    "ConsumerConfigItem": [
      {
        "Name": "fetch.max.wait.ms",
        "Value": 100
      },
      {
        "Name": "max.poll.records", // Her poll döngüsünde cosnumer'ın en fazla kaç kayıt alacağı.
        "Value": 1
      },
      {
        "Name": "session.timeout.ms", // Bir consumer session.timeout.ms süresi boyunca heartbeat göndermezse "ölü" olarak kabul edilir ve mevcut consumer'lar arasında yeniden dengeleme yapılır.
        "Value": 60000
      },
      {
        "Name": "heartbeat.interval.ms", // session.timeout.ms süresinin 1/3 kadar bir süre atanması tavsiye edilir.
        "Value": 20000
      },
      {
        "Name": "max.poll.interval.ms", // Consumer max.poll.interval.ms süresi boyunca yeni kayıt talep etmezse ölü olarak kabul edilir ve mevcut consumer'lar arasında yeniden dengeleme yapılır.
        "Value": 5000
      },
      {
        "Name": "request.timeout.ms", // Consumer'ın broker'dan yanıt bekleyeceği max süredir. Eğer bu süre içerisinde broker'dan bir yanıt alınamazsa mevcut connection kapatılır ve yeniden connection denemesi yapılır. Düşük bir süre verilmesi zaten yanıt veremeyen broker üzerinde daha fazla aşırı yüklenmeye sebep olur.
        "Value": 30000
      },
      {
        "Name": "auto.offset.reset", // Consumer ilk defa kayıtları almaya hangi offset'ten başlayacağını belittir. Biz en baştan başlayacak şekilde ayarladık. Diğer "earliest" ten farklı olarak "latest" olarak da ayarlanabilir. "latest" olarak ayarlanırsa en son yani en güncel kayıttan itibaren kayıt almaya başlanır.
        "Value": 1 // earliest
      },
      {
        "Name": "enable.auto.commit",
        "Value": false
      },
      {
        "Name": "partition.assignment.strategy", // Consumer'lar arasındaki partition atama stratejisidir. Yeniden dengeleme süresini azaltmak için "cooperative rebalance" tercih ettik.
        "Value": 2 // CooperativeSticky
      }
    ]
  }
}


